<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>That Open – IFC demo</title>
  <style>
      *, *::before, *::after {
          box-sizing: border-box;
      }
      html, body {
          height: 100%;
          margin: 0;
          min-width: 0;
          font: 14px/1.4 system-ui, sans-serif;
      }
    /*#app { position:fixed; inset:0; display:grid; grid-template-columns: 1fr 320px; }*/
    /*#viewport { position:relative; background:#0b0f14; }*/
      #viewport {
          background: #0b0f14;
          min-width: 0;
      }
    /*#ui { border-left:1px solid #1f2a35; background:#0f151c; color:#cfe3ff; overflow:auto; }*/
    #toolbar { display:flex; gap:8px; padding:10px; position:absolute; left:10px; top:10px; z-index:10;
               background:#101821cc; border:1px solid #1f2a35; border-radius:10px; backdrop-filter: blur(4px); }
    #file { display:none; }
    .btn { cursor:pointer; padding:8px 10px; border:1px solid #2b3a4a; border-radius:8px; background:#13202e; color:#d7e7ff; }
    .btn:hover { background:#14293a; }
    #props { padding:16px; }
    .pset { margin:0 0 12px 0; border:1px solid #213142; border-radius:10px; overflow:hidden; }
    .pset h3 { margin:0; padding:8px 10px; background:#102030; font-size:13px; }
    .prop { display:flex; gap:8px; padding:6px 10px; border-top:1px solid #1b2a3a; }
    .prop .k { opacity:.8; min-width:120px; }
      /* Base layout (desktop): right sidebar */
      #app {
          position: fixed;
          inset: 0;
          display: grid;
          grid-template-columns: minmax(0, 1fr) clamp(260px, 32vw, 320px);
          grid-template-rows: minmax(0, 1fr);
      }

      #ui {
          border-left: 1px solid #1f2a35;
          background: #0f151c;
          color: #cfe3ff;
          overflow: auto; /* scroll inside the panel if needed */
          width: auto; /* IMPORTANT: let the grid control width */
          max-width: none; /* don’t lock width */
          min-width: 0; /* allow it to shrink */
      }

      /* Narrow screens: convert sidebar into a bottom drawer */
      @media (max-width: 900px) {
          #app {
              grid-template-columns: 1fr;
              /* grid-template-rows: minmax(0, 1fr) min(40vh, 340px); */
              grid-template-rows: minmax(0, 1fr) min(30vh, 340px);
          }

          #viewport {
              grid-row: 1;
              grid-column: 1;
          }

          #ui {
              grid-row: 2;
              grid-column: 1;
              border-left: none;
              border-top: 1px solid #1f2a35;
              width: 100%;
              height: 100%;
              max-width: none;
              min-width: 0;
              overflow: auto;
              z-index: 10;
              background: #00000010;
          }
      }

      /* Optional: for very short windows, clamp the drawer a bit higher */
              @media (max-height: 600px) and (max-width: 900px) {
                  #app {
                      grid-template-rows: minmax(0, 1fr) min(50vh, 280px);
                  }
              }

  </style>
</head>
<body>
  <div id="app">
    <div id="viewport">
        <div id="toolbar">
            <label class="btn" for="file">Open IFC…</label>
            <input id="file" type="file" accept=".ifc,.ifczip" />
            <button id="clearSel" class="btn">Clear selection</button>
            <button id="resetView" class="btn">Reset view</button>
        </div>
      <div id="container" style="position:absolute; inset:0;"></div>
    </div>
    <div id="ui">
      <div id="props">
        <h2 style="margin-top:12px;">Properties</h2>
        <p>Click an element to view <b>Quantities</b> and <b>Information</b>.</p>
        <div id="psets"></div>
      </div>
    </div>
  </div>

  <script type="module">
    
      //import * as OBC from "https://cdn.jsdelivr.net/npm/@thatopen/components@2/+esm";
      //import * as OBF from "https://cdn.jsdelivr.net/npm/@thatopen/components-front@2/+esm";      
      // Use the package’s ESM file directly (unpkg), not jsDelivr +esm
      //import * as FRAGS from "https://unpkg.com/@thatopen/fragments@2.8.3/dist/index.mjs";

      //import * as OBC from "https://cdn.jsdelivr.net/npm/@thatopen/components@2.11.3/+esm";
      //import * as OBF from "https://cdn.jsdelivr.net/npm/@thatopen/components-front@2.4.2/+esm";

      //import * as FRAGS from "https://cdn.jsdelivr.net/npm/@thatopen/fragments@2.8.3/dist/index.mjs";

      // Components core + frontend helpers
      import * as OBC from "https://cdn.jsdelivr.net/npm/@thatopen/components@3.1.3/+esm";      
      import * as OBF from "https://cdn.jsdelivr.net/npm/@thatopen/components-front@3.1.7/+esm";
      
      // Fragments (use esm.sh here because jsDelivr’s +esm wrapper can be odd for this package)
      import * as FRAGS from "https://esm.sh/@thatopen/fragments@3.1.7";      
      import * as WebIFC from "https://cdn.jsdelivr.net/npm/web-ifc@0.0.71/web-ifc-api.js";

      //import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js";
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157.0/+esm";




      //Raggar-lösning med att läsa in Properties separat:
      // WebIFC API used to read properties directly from the IFC
      const ifcApi = new WebIFC.IfcAPI();
      // point WebIFC to the CDN copy of the wasm (note trailing slash)
      ifcApi.SetWasmPath("https://cdn.jsdelivr.net/npm/web-ifc@0.0.71/", true);
      await ifcApi.Init();
      let webIfcModelID = null;     // web-ifc model handle currently opened
      let ifcBytesCache = null;     // keep last IFC bytes so we can close/dispose on reload

      let theGrid = null; //DALMAN
      let theBox = null; //DALMAN

      let projectUnitsCache = null;

      function unitSymbolFromIfcNamedUnit(u) {
          if (!u) return "";
          // IfcSIUnit typically: { UnitType, Name, Prefix }
          const base = siNameToBaseSymbol(u ?.Name ?.value || u ?.Name);
          const pref = siPrefixSymbol(u ?.Prefix ?.value || u ?.Prefix);
          if (base) return pref + base;
          // IfcConversionBasedUnit may have a readable Name like "inch" / "foot"
          const human = u ?.Name ?.value || u ?.Name;
          return human || "";
      }

      function pickUnit(units, typeKey) {
          // typeKey: "LENGTHUNIT"|"AREAUNIT"|"VOLUMEUNIT"
          const arr = units ?.Units || [];
          for (const h of arr) {
              const u = ifcApi.GetLine(webIfcModelID, asId(h));
              const ut = String(u ?.UnitType ?.value || u ?.UnitType || "").toUpperCase();
              if (ut === typeKey) return u;
          }
          return null;
      }

      function lengthSymbolFromUnits(units) {
          return unitSymbolFromIfcNamedUnit(pickUnit(units, "LENGTHUNIT")) || "m";
      }

      function areaSymbolFromUnits(units) {
          const area = pickUnit(units, "AREAUNIT");
          if (area) return unitSymbolFromIfcNamedUnit(area);
          // fallback: length²
          return withExponent(lengthSymbolFromUnits(units), 2);
      }

      function volumeSymbolFromUnits(units) {
          const vol = pickUnit(units, "VOLUMEUNIT");
          if (vol) return unitSymbolFromIfcNamedUnit(vol);
          // fallback: length³
          return withExponent(lengthSymbolFromUnits(units), 3);
      }

      function getProjectUnits() {
          if (projectUnitsCache) return projectUnitsCache;
          // find first IfcProject and resolve UnitsInContext
          const ids = ifcApi.GetLineIDsWithType(webIfcModelID, WebIFC.IFCPROJECT);
          const id = typeof ids.get === "function" ? ids.get(0) : ids[0];
          const proj = id ? ifcApi.GetLine(webIfcModelID, id) : null;
          const units = proj ?.UnitsInContext ? ifcApi.GetLine(webIfcModelID, asId(proj.UnitsInContext)) : null;
          projectUnitsCache = units || null;
          return projectUnitsCache;
      }

      // call this whenever you open a new model to clear cache
      function resetProjectUnitsCache() {
          projectUnitsCache = null;
      }


      // --- World (scene, camera, renderer) -------------------------------------
    const components = new OBC.Components();
    const worlds = components.get(OBC.Worlds);
    const world = worlds.create(
      OBC.SimpleScene,
      OBC.OrthoPerspectiveCamera,
      OBF.PostproductionRenderer
    );

    // Scene + renderer in the right div
    world.scene = new OBC.SimpleScene(components);
    world.scene.setup();
    //world.scene.three.background = null;
      world.scene.three.background = new THREE.Color().setHex(0x0b0f14);

    // Renderer (binds to your #container)
    world.renderer = new OBF.PostproductionRenderer(components, document.getElementById("container"));

    // Camera
    world.camera = new OBC.OrthoPerspectiveCamera(components);

    // Orbit navigation
    // Initial orbit-style view (no setNavigationMode needed)
    //await world.camera.setNavigationMode(new OBC.OrbitMode()); // 3D orbit mode
    await world.camera.controls.setLookAt(20, 15, 25, 0, 0, 0); // pos -> target

    // Start the engine AFTER wiring scene/renderer/camera
    // make it go
    components.init();

    // Optional grid
    theGrid = components.get(OBC.Grids).create(world);

    // --- Fragments core (worker) ---------------------------------------------
    // For a real app, copy the worker to your app and serve locally.
    const workerUrl = URL.createObjectURL(
      new File([await (await fetch("https://thatopen.github.io/engine_fragment/resources/worker.mjs")).blob()],
      "worker.mjs", { type: "text/javascript" })
      );

    
    // FragmentsManager from Components (OBC)
    const fragments = components.get(OBC.FragmentsManager);
    fragments.init(workerUrl);

    
    // keep Fragments' internal buffers updated with camera changes
    world.camera.controls.addEventListener("rest", () => fragments.core.update(true));

    world.onCameraChanged.add((camera) => {
        for (const [, model] of fragments.list) model.useCamera(camera.three);
        fragments.core.update(true);
    });

    // when a model is registered, add it to the scene
    fragments.list.onItemSet.add(({ value: model }) => {
        model.useCamera(world.camera.three);
        world.scene.three.add(model.object);
        fragments.core.update(true);
    });

    // --- Raycasting + Highlighter (click to select) --------------------------
    // Raycaster bound to this world
    components.get(OBC.Raycasters).get(world);

    const highlighter = components.get(OBF.Highlighter);
    highlighter.setup({
      world,        
        selectMaterialDefinition: { color: new THREE.Color("#bcf124"), opacity: 1, transparent: false, renderedFaces: 0 }       
      });

      

    // --- Load IFC from disk -> convert -> show --------------------------------
    const fileInput = document.getElementById("file");
    fileInput.addEventListener("change", onOpenIfc);

    // IfcImporter converts IFC bytes -> Fragments bytes in the browser.
    const importer = new FRAGS.IfcImporter();
    // Set the web-ifc WASM path (from the official docs demo)
    //importer.wasm = { absolute: true, path: "https://unpkg.com/web-ifc@0.0.69/" }; // :contentReference[oaicite:0]{index=0}
      importer.wasm = { absolute: true, path: "https://cdn.jsdelivr.net/npm/web-ifc@0.0.71/" };

    async function onOpenIfc(e) {
      const file = e.target.files?.[0];
      if (!file) return;

      // Ifc -> Fragments (ArrayBuffer)
      

     // Convert IFC -> Fragments bytes (unchanged)
    const ifcBytes = new Uint8Array(await file.arrayBuffer());
    ifcBytesCache = ifcBytes; //Raggar-IFC-props

    //Close previous web - ifc model if any (Raggar-IFC-Props)
    if (webIfcModelID !== null) {
                try { ifcApi.CloseModel(webIfcModelID); } catch { }
                webIfcModelID = null;
    }

    //Open in web-ifc so we can read property sets later (Raggar-IFC-Props)
    webIfcModelID = ifcApi.OpenModel(ifcBytes, {
        // you can pass IFC load settings here if needed
        });

        resetProjectUnitsCache();

     const fragBytes = await importer.process({
         bytes: ifcBytes,
         progressCallback: (p) => console.log("IFC→Fragments", Math.round(p * 100) + "%")
     });

      

      // Load via the initialized FragmentsManager
      const modelId = file.name.replace(/\.(ifc|ifczip)$/i, "");
      await fragments.core.load(fragBytes, { modelId });
      fragments.core.update(true);

      // Fit view
      const boxer = components.get(OBC.BoundingBoxer);
      

        boxer.list.clear();
        boxer.addFromModels();                 // or boxer.addFromModelIdMap(selection)
        const box = boxer.get();               // <-- returns a THREE.Box3
        theBox = box.clone();
        await world.camera.controls.fitToBox(box, true);
        boxer.list.clear();
        theGrid.three.position.y = theBox.min.y;
        
    }

    // --- Selection -> fetch properties -> show filtered psets -----------------
    const psetsRoot = document.getElementById("psets");    

      //FOR RAGGAR-IFC-PROPS
      

      function asId(x) {
          // Accept shapes: 123, "123", { value: 123 }, { expressID: 123 }
          if (x == null) return null;
          if (typeof x === "object") {
              if ("value" in x) return Number(x.value);
              if ("expressID" in x) return Number(x.expressID);
          }
          return Number(x);
      }


      //FOR RAGGAR-IFC-PROPS v2
      highlighter.events.select.onHighlight.add(async (modelIdMap) => {
          const modelId = Object.keys(modelIdMap)[0];
          if (!modelId) return;
          const ids = [...modelIdMap[modelId]];
          if (!ids.length) return;

          const model = fragments.list.get(modelId);
          if (!model) return;

          // Get item data for the first selected drawcall/fragment id
          const [item] = await model.getItemsData([ids[0]]);
          //const expressID = item ?._localId;
          //if (expressID == null) return;
          const expressID = asId(item ?._localId);   // <-- normalize here
          if (expressID == null || Number.isNaN(expressID)) return;

          const psets = await getPsetsForElement(expressID);
          renderFilteredPsetsFromWebIFC(psets);

          //console.log(highlighter); //DALMAN
      });


      //FORTSÄTTER MED RAGGAR-IFC-PROPS  

      function isBsabCodeString(s) {
          // 27 | 27.C | 43.CB | 27.D/11
          return /^[0-9]+(?:\.[A-Za-z]{1,2})?(?:\/[0-9]+)?$/.test(s.trim());
      }

      function normalizeBsab(s) {
          // Uppercase the letter chunk after the dot, keep numbers as-is
          // 27.c  -> 27.C
          // 43.cb -> 43.CB
          // 27.d/11 -> 27.D/11
          return s.replace(
              /^([0-9]+)(?:\.([A-Za-z]{1,2}))?(?:\/([0-9]+))?$/,
              (_, n, letters = "", tail = "") =>
                  letters
                      ? `${n}.${letters.toUpperCase()}${tail ? `/${tail}` : ""}`
                      : `${n}${tail ? `/${tail}` : ""}`
          );
      }


      // Find the element's type (IfcRelDefinesByType → RelatingType)
      function getTypeIdForElement(expressID) {
          const targetId = asId(expressID);
          const relIDs = ifcApi.GetLineIDsWithType(webIfcModelID, WebIFC.IFCRELDEFINESBYTYPE);
          const n = typeof relIDs.size === "function" ? relIDs.size() : relIDs.length;

          for (let i = 0; i < n; i++) {
              const relID = typeof relIDs.get === "function" ? relIDs.get(i) : relIDs[i];
              if (!relID) continue;
              const rel = ifcApi.GetLine(webIfcModelID, relID);
              if (!rel ?.RelatedObjects || !rel.RelatingType) continue;
              const related = rel.RelatedObjects || [];
              const isOurs = related.some(o => asId(o) === targetId);
              if (!isOurs) continue;
              return asId(rel.RelatingType);
          }
          return null;
      }

      // Read Psets directly listed on an IfcTypeObject via HasPropertySets
      function getPsetsFromTypeHasPropertySets(typeObj) {
          const out = [];
          const hps = typeObj ?.HasPropertySets || [];
          for (const h of hps) {
              const def = ifcApi.GetLine(webIfcModelID, asId(h));
              if (!def) continue;
              const kind = getIfcKind(def); // uses your robust detector
              if (kind === "IFCPROPERTYSET") {
                  const name = getIfcName(def);
                  const props = (def.HasProperties || [])
                      .map(p => ifcApi.GetLine(webIfcModelID, asId(p)))
                      .filter(Boolean)
                      .map(parseIfcProperty);
                  out.push({ kind: "Pset", name, props, _origin: "Type" });
              } else if (kind === "IFCELEMENTQUANTITY") {
                  const name = getIfcName(def);
                  const props = (def.Quantities || [])
                      .map(q => ifcApi.GetLine(webIfcModelID, asId(q)))
                      .filter(Boolean)
                      .map(parseIfcQuantity);
                  out.push({ kind: "Quantities", name, props, _origin: "Type" });
              }
          }
          return out;
      }

      // Also check if the type itself has RelDefinesByProperties (less common but possible)
      function getPsetsFromTypeRDP(typeId) {
          const out = [];
          const relType = WebIFC.IFCRELDEFINESBYPROPERTIES;
          const relIDs = ifcApi.GetLineIDsWithType(webIfcModelID, relType);
          const n = typeof relIDs.size === "function" ? relIDs.size() : relIDs.length;

          for (let i = 0; i < n; i++) {
              const relID = typeof relIDs.get === "function" ? relIDs.get(i) : relIDs[i];
              if (!relID) continue;
              const rel = ifcApi.GetLine(webIfcModelID, relID);
              if (!rel ?.RelatedObjects || !rel.RelatingPropertyDefinition) continue;

              const related = rel.RelatedObjects || [];
              const hitsType = related.some(o => asId(o) === typeId);
              if (!hitsType) continue;

              const pd = rel.RelatingPropertyDefinition;
              const def = pd ? ifcApi.GetLine(webIfcModelID, asId(pd)) : null;
              if (!def) continue;

              const kind = getIfcKind(def);
              if (kind === "IFCPROPERTYSET") {
                  const name = getIfcName(def);
                  const props = (def.HasProperties || [])
                      .map(p => ifcApi.GetLine(webIfcModelID, asId(p)))
                      .filter(Boolean)
                      .map(parseIfcProperty);
                  out.push({ kind: "Pset", name, props, _origin: "Type" });
              } else if (kind === "IFCELEMENTQUANTITY") {
                  const name = getIfcName(def);
                  const props = (def.Quantities || [])
                      .map(q => ifcApi.GetLine(webIfcModelID, asId(q)))
                      .filter(Boolean)
                      .map(parseIfcQuantity);
                  out.push({ kind: "Quantities", name, props, _origin: "Type" });
              }
          }
          return out;
      }


      // More resilient kind detection for web-ifc objects
      function getIfcKind(def) {
          // Primary: numeric type code
          if (def ?.type === WebIFC.IFCPROPERTYSET) return "IFCPROPERTYSET";
          if (def ?.type === WebIFC.IFCELEMENTQUANTITY) return "IFCELEMENTQUANTITY";

          // Fallbacks: string name fields that exist in some builds
          const n = def ?.name || def ?.constructor ?.name || "";
          if (/IfcPropertySet$/i.test(n)) return "IFCPROPERTYSET";
          if (/IfcElementQuantity$/i.test(n)) return "IFCELEMENTQUANTITY";

          return "";
      }


      //FORTSÄTTER MED RAGGAR-IFC-PROPS v2      

      

      async function getPsetsForElement(expressID) {
          if (webIfcModelID == null) return [];

          const targetId = asId(expressID);

          // A) Instance-level Psets via IfcRelDefinesByProperties (your existing logic)
          const relType = WebIFC.IFCRELDEFINESBYPROPERTIES;
          const relIDs = ifcApi.GetLineIDsWithType(webIfcModelID, relType);
          const n = typeof relIDs.size === "function" ? relIDs.size() : relIDs.length;

          const instancePsets = [];
          for (let i = 0; i < n; i++) {
              const relID = typeof relIDs.get === "function" ? relIDs.get(i) : relIDs[i];
              if (!relID) continue;

              const rel = ifcApi.GetLine(webIfcModelID, relID);
              if (!rel || !rel.RelatedObjects || !rel.RelatingPropertyDefinition) continue;

              const related = rel.RelatedObjects || [];
              const isOurs = related.some(o => asId(o) === targetId);
              if (!isOurs) continue;

              const pd = rel.RelatingPropertyDefinition;
              const def = pd ? ifcApi.GetLine(webIfcModelID, asId(pd)) : null;
              if (!def) continue;

              const kind = getIfcKind(def);
              if (kind === "IFCPROPERTYSET") {
                  const name = getIfcName(def);
                  const props = (def.HasProperties || [])
                      .map(p => ifcApi.GetLine(webIfcModelID, asId(p)))
                      .filter(Boolean)
                      .map(parseIfcProperty);
                  instancePsets.push({ kind: "Pset", name, props, _origin: "Instance" });
              } else if (kind === "IFCELEMENTQUANTITY") {
                  const name = getIfcName(def);
                  const props = (def.Quantities || [])
                      .map(q => ifcApi.GetLine(webIfcModelID, asId(q)))
                      .filter(Boolean)
                      .map(parseIfcQuantity);
                  instancePsets.push({ kind: "Quantities", name, props, _origin: "Instance" });
              }
          }

          // B) Type-level Psets
          const typeId = getTypeIdForElement(targetId);
          let typePsets = [];
          if (typeId != null) {
              const typeObj = ifcApi.GetLine(webIfcModelID, typeId);
              if (typeObj) {
                  typePsets = [
                      ...getPsetsFromTypeHasPropertySets(typeObj),
                      ...getPsetsFromTypeRDP(typeId),
                  ];
              }
          }

          // C) Merge (instance has priority over type when names collide)
          //    You can change the dedupe key as needed; using set name + kind here.
          const seen = new Set();
          const merged = [];
          for (const s of [...instancePsets, ...typePsets]) {
              const key = `${s.kind}|${s.name}`;
              if (seen.has(key)) continue;
              seen.add(key);
              merged.push(s);
          }

          return merged;
      }


      function getIfcName(obj) {
          return obj ?.Name ?.value ?? obj ?.Name ?? "(unnamed)";
      }

      // Resolve a symbol from an IfcUnit (IfcSIUnit / IfcConversionBasedUnit / IfcDerivedUnit / IfcMonetaryUnit)
      function symbolFromIfcUnit(unitObj, qtyTypeName) {
          if (!unitObj) return "";

          // If this is a HANDLE, resolve it first
          const resolved = unitObj.value != null ? ifcApi.GetLine(webIfcModelID, Number(unitObj.value)) : unitObj;
          if (!resolved) return "";

          // IfcSIUnit: { UnitType, Name, Prefix }
          if (resolved.Name || resolved.Prefix) {
              const base = siNameToBaseSymbol(resolved ?.Name ?.value || resolved ?.Name);
              const pref = siPrefixSymbol(resolved ?.Prefix ?.value || resolved ?.Prefix);
              return withExponent(pref + base, inferExponentFromQuantityKind(qtyTypeName));
          }

          // IfcConversionBasedUnit: { Name, ConversionFactor }
          // We don’t compute the factor here; just show the human label (e.g., "inch", "foot")
          if (resolved.Name) {
              return String(resolved ?.Name ?.value || resolved ?.Name);
          }

          // IfcDerivedUnit: Elements = [{ Unit: Handle, Exponent: n }, ...]
          if (Array.isArray(resolved ?.Elements)) {
              const parts = [];
              for (const el of resolved.Elements) {
                  const baseSym = symbolFromIfcUnit(el.Unit, null) || "?";
                  const exp = Number(el.Exponent ?.value ?? el.Exponent ?? 1);
                  parts.push(exp === 1 ? baseSym : `${baseSym}${exp === 2 ? "²" : exp === 3 ? "³" : `^${exp}`}`);
              }
              return parts.join("·"); // e.g., "N·m⁻¹" (we don’t handle negative nicely here)
          }

          // IfcMonetaryUnit (rare for quantities): { Currency }
          if (resolved.Currency) {
              return String(resolved.Currency ?.value || resolved.Currency);
          }

          return "";
      }

      // When the Pset property itself defines Unit, that wins.
      function unitSymbolFromPropertyOverride(prop, qtyTypeName, projectUnits) {
          if (!prop ?.Unit) return "";
          const sym = symbolFromIfcUnit(prop.Unit, qtyTypeName);
          if (sym) return sym;

          // If override exists but we failed to resolve, don’t silently fall back — try project units as a backup
          return symbolFromProjectUnits(qtyTypeName, projectUnits);
      }

      function symbolFromProjectUnits(qtyTypeName, projectUnits) {
          if (!projectUnits) return defaultUnitForQuantityType(qtyTypeName);
          if (/IFCLENGTHMEASURE$/i.test(qtyTypeName)) return lengthSymbolFromUnits(projectUnits);
          if (/IFCAREAMEASURE$/i.test(qtyTypeName)) return areaSymbolFromUnits(projectUnits);
          if (/IFCVOLUMEMEASURE$/i.test(qtyTypeName)) return volumeSymbolFromUnits(projectUnits);
          return defaultUnitForQuantityType(qtyTypeName);
      }

      function inferExponentFromQuantityKind(qtyTypeName) {
          const t = String(qtyTypeName || "");
          if (/AREA$/i.test(t)) return 2;
          if (/VOLUME$/i.test(t)) return 3;
          return 1;
      }

      

      function parseIfcProperty(prop) {
          const name = getIfcName(prop);
          const nv = prop ?.NominalValue;

          // Get a string view of the value (covers IfcIdentifier, IfcLabel, etc.)
          const rawStr = (nv ?.value ?? nv ?.Value ?? "").toString().trim();

          //If it looks like a BSAB96 code, show it verbatim (formatted), no units/rounding
          if (rawStr && isBsabCodeString(rawStr)) {
              return { name, value: normalizeBsab(rawStr) };
          }

          // numeric-like value (covers common cases)
          const raw =
              nv ?.value ?? nv ?.Value ?? null;

          // Measure type from NominalValue (e.g., IFCLENGTHMEASURE / IFCAREAMEASURE / IFCVOLUMEMEASURE)
          const measureType = String(nv ?.name || nv ?.constructor ?.name || nv ?.typeName || "").toUpperCase();

          // 1) If property has its own Unit, it overrides project units (spec rule)
          const unitsCtx = getProjectUnits();
          let unitSym = unitSymbolFromPropertyOverride(prop, measureType, unitsCtx);

          // 2) If no explicit Unit, use project UnitsInContext (fallback by measure type)
          if (!unitSym) {
              unitSym = symbolFromProjectUnits(measureType, unitsCtx);
          }

          // Format number with one decimal, but drop trailing ".0"
          const num = oneDecimal(raw);

          // Non-numeric properties: just show raw value
          if (num === "") {
              const rawStr = nv ?.value ?? nv ?.Value ?? "";
              return { name, value: String(rawStr) };
          }


          //Update: always convert to meters (m2, m3)

          //// Present as "32.5 [m]" or "342 [m²]"
          //const value = unitSym ? `${num} [${unitSym}]` : `${num}`;
          //if (logUnitSym) {
          //    console.log(value); //DALMAN
          //}
          //return { name, value };

          let rawNum = typeof raw === "number" ? raw : parseFloat(raw);
          if (!Number.isFinite(rawNum)) {
              // Non-numeric property: show as-is
              const rawStr = (prop ?.NominalValue ?.value ?? prop ?.NominalValue ?.Value ?? "").toString();
              return { name, value: rawStr };
          }

          // Normalize unit symbol for matching
          const u = String(unitSym || "").toLowerCase();

          // mm² -> m²
          if (/^mm(?:²|2)$/.test(u)) {
              const numM = oneDecimal(rawNum / 1e6);        // 1 mm² = 1e-6 m²
              return { name, value: `${numM} [m²]` };
          }

          // mm³ -> m³
          if (/^mm(?:³|3)$/.test(u)) {
              const numM = oneDecimal(rawNum / 1e9);        // 1 mm³ = 1e-9 m³
              return { name, value: `${numM} [m³]` };
          }

          // cm² -> m²
          if (/^cm(?:²|2)$/.test(u)) {
              const numM = oneDecimal(rawNum / 1e4);        // 1 cm² = 1e-4 m²
              return { name, value: `${numM} [m²]` };
          }
          // cm³ -> m³
          if (/^cm(?:³|3)$/.test(u)) {
              const numM = oneDecimal(rawNum / 1e6);        // 1 cm³ = 1e-6 m³
              return { name, value: `${numM} [m³]` };
          }

          // default presentation (already rounded to one decimal elsewhere)
          const value = unitSym ? `${num} [${unitSym}]` : `${num}`;
          return { name, value };
      }


      

      // --- number formatting (max one decimal) -------------------------------      
      function oneDecimal(n) {
          const x = typeof n === "number" ? n : parseFloat(n);
          if (!Number.isFinite(x)) return "";
          const rounded = x.toFixed(1);      // string like "32.0" or "32.5"
          return rounded.endsWith(".0")
              ? rounded.slice(0, -2)           // strip the ".0"
              : rounded;
      }


      // --- unit helpers ----------------------------------------------------------
      function siPrefixSymbol(prefix) {
          // Common IFC SI prefixes
          const map = { KILO: "k", HECTO: "h", DECA: "da", DECI: "d", CENTI: "c", MILLI: "m", MICRO: "μ", NANO: "n" };
          return map[String(prefix || "").toUpperCase()] || "";
      }
      function siNameToBaseSymbol(name) {
          // IFC SI names -> base symbol (no exponent)
          const map = {
              METRE: "m", GRAM: "g", SECOND: "s", AMPERE: "A", KELVIN: "K", MOLE: "mol",
              CANDELA: "cd", SQUARE_METRE: "m²", CUBIC_METRE: "m³"
          };
          return map[String(name || "").toUpperCase()] || "";
      }
      //function siNameToBaseSymbol(name) {
      //    const map = {
      //        METRE: "m", GRAM: "g", SECOND: "s", AMPERE: "A", KELVIN: "K", MOLE: "mol", CANDELA: "cd"
      //    };
      //    return map[String(name || "").toUpperCase()] || "";
      //}
      //function withExponent(sym, qtyTypeName) {
      //    // If the SI unit doesn't already encode area/volume, add exponent by quantity kind
      //    if (!sym) return sym;
      //    const t = String(qtyTypeName || "");
      //    if (/IfcQuantityArea$/i.test(t) && !/[²]/.test(sym)) return sym + "²";
      //    if (/IfcQuantityVolume$/i.test(t) && !/[³]/.test(sym)) return sym + "³";
      //    return sym;
      //}
      function withExponent(sym, exp) {
          if (!sym) return sym;
          if (exp === 2 && !/[²]/.test(sym)) return sym + "²";
          if (exp === 3 && !/[³]/.test(sym)) return sym + "³";
          return sym;
      }

      // Try to resolve a readable unit label from an IfcNamedUnit / IfcSIUnit / IfcConversionBasedUnit
      function resolveUnitSymbol(unitObj, qtyTypeName) {
          if (!unitObj) return "";
          // IfcSIUnit shape often has { UnitType, Name, Prefix }
          if (unitObj.Name || unitObj.Prefix) {
              const base = siNameToBaseSymbol(unitObj.Name ?.value || unitObj.Name);
              const prefix = siPrefixSymbol(unitObj.Prefix ?.value || unitObj.Prefix);
              const sym = prefix + base;
              return withExponent(sym, qtyTypeName);
          }
          // IfcConversionBasedUnit can expose a human name (e.g., "inch", "foot")
          if (unitObj.Name) {
              const human = unitObj.Name ?.value || unitObj.Name;
              return String(human);
          }
          return "";
      }

      // Fallback defaults when IFC omits explicit units
      function defaultUnitForQuantityType(qtyTypeName) {
          if (/IfcQuantityLength$/i.test(qtyTypeName)) return "m";
          if (/IfcQuantityArea$/i.test(qtyTypeName)) return "m²";
          if (/IfcQuantityVolume$/i.test(qtyTypeName)) return "m³";
          if (/IfcQuantityWeight$/i.test(qtyTypeName)) return "kg";
          if (/IfcQuantityTime$/i.test(qtyTypeName)) return "s";
          return "";
      }

      // --- parse a single Ifc*Quantity into {name, value} with unit ---------------
      
      

      function parseIfcQuantity(q) {
          const name = getIfcName(q);
          const raw =
              q ?.LengthValue ?.value ?? q ?.AreaValue ?.value ?? q ?.VolumeValue ?.value ??
                  q ?.CountValue ?.value ?? q ?.WeightValue ?.value ?? q ?.TimeValue ?.value ??
                      q ?.NominalValue ?.value ?? q ?.NominalValue ?.Value ?? null;

          const typeName = String(q ?.name || q ?.constructor ?.name || "").toUpperCase();
          const unitsCtx = getProjectUnits();

          // prefer explicit Unit on the quantity itself, else fallback to project units by type
          let unitSym = "";
          if (q ?.Unit) {
              unitSym = symbolFromIfcUnit(q.Unit, typeName);
          }
          if (!unitSym) {
              if (typeName.includes("IFCQUANTITYLENGTH")) unitSym = lengthSymbolFromUnits(unitsCtx);
              else if (typeName.includes("IFCQUANTITYAREA")) unitSym = areaSymbolFromUnits(unitsCtx);
              else if (typeName.includes("IFCQUANTITYVOLUME")) unitSym = volumeSymbolFromUnits(unitsCtx);
              else unitSym = defaultUnitForQuantityType(typeName);
          }

          const num = oneDecimal(raw);
          const value = unitSym ? `${num} [${unitSym}]` : `${num}`;
          return { name, value };
      }






    // Clear selection button
    document.getElementById("clearSel").onclick = async () => {
      await highlighter.clear("select");
        psetsRoot.innerHTML = "";
        //theGrid.three.position.y = -1000.0; //DALMAN
        theGrid.three.position.y = theBox.min.y; //DALMAN
      };

      // Reset view button
      document.getElementById("resetView").onclick = async () => {
          await world.camera.controls.fitToBox(theBox, true);
      };

      
      function renderFilteredPsetsFromWebIFC(psets) {
          const wanted = new Set(["Quantities", "Information", "BaseQuantities", "Identity Data"]);
          const root = document.getElementById("psets");
          root.innerHTML = "";

          //console.log(psets); //DALMAN 

          for (const set of psets) {
              const setName = set.name || set.kind || "Pset";
              //console.log(setName); //DALMAN 
              if (!wanted.has(setName)) continue;

              const wrap = document.createElement("div");
              wrap.className = "pset";
              wrap.innerHTML = `<h3>${setName}</h3>`;
              for (const p of set.props) {
                  const val = p.value ?? "";
                  const row = document.createElement("div");
                  row.className = "prop";
                  //row.innerHTML = `<div class="k">${p.name}</div><div class="v">${p.value ?? ""}</div>`;
                  row.innerHTML = `<div class="k">${p.name}</div><div class="v">${val}</div>`;

                  wrap.appendChild(row);
              }
              root.appendChild(wrap);
          }

          if (!root.children.length) {
              root.innerHTML = "<p>No matching property sets on this element.</p>";
          }
      }

  </script>
</body>
</html>
