<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - V8.0</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
        body {
            background-color: #fff;
            color: #444;
        }

        a {
            color: red;
        }

        #my-div-1 {
            position: absolute;
            top: 25%;
            left: 2%;            
            width: 100%;
        }

        #my-div-2 {
            position: absolute;
            bottom: 5%;
            left: 2%;
            width: 100%;
        }

        #my-div-3 {
            position: absolute;
            bottom: 5%;
            left: 40%;
            width: 100%;
        }

        .slidecontainer {
            width: 100%; /* Width of the outside container */
        }

        /* The slider itself */
        .slider {
            -webkit-appearance: none; /* Override default CSS styles */
            position: absolute;
            width: 90%; /* Full-width */
            top: 75%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 15px; /* Specified height */
            background: #d3d3d3; /* Grey background */
            outline: none; /* Remove outline */
            opacity: 0.7; /* Set transparency (for mouse-over effects on hover) */
            -webkit-transition: .2s; /* 0.2 seconds transition on hover */
            transition: opacity .2s;
        }

            /* Mouse-over effects */
            .slider:hover {
                opacity: 1; /* Fully shown on mouse-over */
            }

            /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
            .slider::-webkit-slider-thumb {
                -webkit-appearance: none; /* Override default look */
                width: 35px; /* Set a specific slider handle width */
                height: 35px; /* Slider handle height */
                background: #04AA6D; /* Green background */
                cursor: pointer; /* Cursor on hover */
            }

        .btn {
            background-color: DodgerBlue;
            border: none;
            color: white;
            padding: 12px 16px;
            font-size: 16px;
            cursor: pointer;
        }


            /* Darker background on mouse-over */
            .btn:hover {
                background-color: RoyalBlue;
            }

            .btn:active {
                background-color: #ffbf00;
            }
    </style>
</head>
<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - lookup table<br />
        vertex color values from a range of data values
    </div>

    <button id="chart_button" class="btn"><i class="fa fa-line-chart"></i></button>
    <button id="strains_button" class="btn" style='display: none;'><i class="fa fa-expand"></i> εmax</button>
    <button id="cracks_button" class="btn" style='display: none;'><i class="fa fa-compress"></i> εmin</button>
    <button id="defs_button" class="btn" style='display: none;'><i class="fa fa-crop"></i> γxy</button>
    <button id="play_button" class="btn" style='display: none;'><i class="fa fa-wifi"></i></button>
    <textarea cols="60" rows="3"></textarea>
    <button id="send_button">Send</button>
    <button id="send_k_button">Send k to socket...</button>
    <button id="close_socket_button">Close Socket</button>
    <input type="file" name="inputfile"
           id="inputfile">

    <!-- <input type="range" min="0" max="432" value="216" class="slider" id="ar_slider" style='display: none;'> -->
    <!-- <input type="range" min="0" max="44" value="22" class="slider" id="ar_slider" style='display: none;'> -->
    <input type="range" min="0" max="2" value="0" class="slider" id="ar_slider" style='display: none;'>

    <div id="container"></div>

    <div id="my-div-1">1650</div>
    <div id="my-div-2">-650</div>
    <div id="my-div-3">D</div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
        "imports": {
        "three": "./js/three/three.module.js"
        }
        }
    </script>

    <script type="module">

        import * as THREE from 'three';

        import { GUI } from './jsm/libs/lil-gui.module.min.js';

        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { Lut } from './jsm/math/Lut.js';

        let container;

        let perpCamera, orthoCamera, renderer, lut;

        let mesh, sprite;
        let scene, uiScene;

        let params;

        let currentSensorIdx = 0;
        let date_time = ' ';

        //let maxValue = -1000;
        //let minValue = 1000;


        let guiMode = 0;
        let activeChart = 0;

        let theStrainsButton = null;
        let theCracksButton = null;
        let theDefsButton = null;

        let thePlayButton = null;
        let isSimulating = false;
        let theIntervalID = 0;

        //websocket stuff
        let theSendButton = null;
        let theSendKButton = null;
        let theCloseSocketButton = null;
        let theTextArea = null;
        let theWebsocket = null;

        let legendTextTop = null;
        let legendTextBottom = null;
        let legendTextDateTime = null;

        init();

        function init() {



            container = document.getElementById('container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            uiScene = new THREE.Scene();

            lut = new Lut();

            //lut.addColorMap('jet', [[0.0, 0x3C4EC2], [0.2, 0x9BBCFF], [0.5, 0xDCDCDC], [0.8, 0xF6A385], [1.0, 0xFF0000]]);
            lut.addColorMap('jet', [[0.0, 0x00007F], [0.125, 0x0000FF], [0.25, 0x007FFF], [0.375, 0x00FFFF], [0.5, 0x7FFF7F], [0.625, 0xFFFF00], [0.75, 0xFF7F00], [0.875, 0xFF0000], [1.0, 0x7F0000]]);
            lut.setColorMap('jet', 128);
            const width = window.innerWidth;
            const height = window.innerHeight;

            //perpCamera = new THREE.PerspectiveCamera( 60, width / height, 1, 100 );
            perpCamera = new THREE.PerspectiveCamera(60, width / height, 0.2, 100);
            perpCamera.position.set(0, 0, 10);
            scene.add(perpCamera);

            orthoCamera = new THREE.OrthographicCamera(- 1, 1, 1, - 1, 1, 2);
            //orthoCamera.position.set(0.5, 0, 1); //Original example
            //orthoCamera.position.set(0.1, 0, 1);
            //orthoCamera.position.set(0.95, 0, 1);
            orthoCamera.position.set(0.95, 0.25, 1);

            sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(lut.createCanvas())
            }));
            //sprite.scale.x = 0.125;
            sprite.scale.x = 0.04;

            uiScene.add(sprite);

            const map = sprite.material.map;
            lut.updateCanvas(map.image);
            map.needsUpdate = true;

            mesh = new THREE.Mesh(undefined, new THREE.MeshLambertMaterial({
                side: THREE.DoubleSide,
                color: 0xF5F5F5,
                vertexColors: true //,
                //wireframe: true
            }));
            scene.add(mesh);

            params = {
                colorMap: 'rainbow',
            };

            console.log('BEFORE calling loadModel');

            loadModel();

            console.log('AFTER calling loadModel');

            legendTextTop = document.getElementById("my-div-1");
            legendTextTop.innerText = ' ';

            legendTextBottom = document.getElementById("my-div-2");
            legendTextBottom.innerText = ' ';

            legendTextDateTime = document.getElementById("my-div-3");
            legendTextDateTime.innerText = ' ';

            var theSlider = document.getElementById("ar_slider");

            theSlider.oninput = function () {
                //output.innerHTML = this.value + Math.floor(Math.random() * 10);
                currentSensorIdx = this.value;
                updateColors();
                updateLegendText();
                render();
            }

            theStrainsButton = document.getElementById("strains_button");
            theCracksButton = document.getElementById("cracks_button");
            theDefsButton = document.getElementById("defs_button");

            thePlayButton = document.getElementById("play_button");

            theSendButton = document.getElementById("send_button");
            theSendButton.addEventListener("click", onClickSendButton);

            theSendKButton = document.getElementById("send_k_button");
            theSendKButton.addEventListener("click", onClickSendKButton);

            theCloseSocketButton = document.getElementById("close_socket_button");
            theCloseSocketButton.addEventListener("click", onClickCloseSocketButton);

            theTextArea = document.querySelector("textarea");


            document.getElementById('inputfile')
                .addEventListener('change', function () {

                    var fr = new FileReader();
                    fr.onload = function () {
                        //document.getElementById('output')
                        //   .textContent = fr.result;

                        //THIS WORKS!!
                        let theDataAsJson = JSON.parse(fr.result);
                        //loadModelFromJSON(theDataAsJson);
                        loadUserDataFromJSON(theDataAsJson);

                        //THIS DOESN'T WORK
                        //let theDataAsJson1 = JSON.parse(fr.result);
                        //let theDataAsJson2 = JSON.parse(theDataAsJson1);
                        //loadModelFromJSON(theDataAsJson2);

                        //loadModelFromJSON(fr.result); //This doesn't work...
                    }

                    fr.readAsText(this.files[0]);
                })

            theStrainsButton.onclick = function () {
                if (activeChart == 1) {
                    //We ARE active, toggle buttons OFF and HIDE slider
                    theStrainsButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'none';
                    activeChart = 0;
                } else {
                    //Activate and SHOW slider
                    theStrainsButton.style.backgroundColor = '#ffbf00';
                    theCracksButton.style.backgroundColor = 'DodgerBlue';
                    theDefsButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'inline-block';
                    activeChart = 1;
                }

                updateColors();
                updateLegendText();
                render();
            }

            theCracksButton.onclick = function () {
                if (activeChart == 2) {
                    //We ARE active, toggle buttons OFF
                    theCracksButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'none';
                    activeChart = 0;
                } else {
                    theCracksButton.style.backgroundColor = '#ffbf00';
                    theStrainsButton.style.backgroundColor = 'DodgerBlue';
                    theDefsButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'inline-block';
                    activeChart = 2;
                }

                updateColors();
                updateLegendText();
                render();
            }

            theDefsButton.onclick = function () {
                if (activeChart == 3) {
                    //We ARE active, toggle buttons OFF
                    theDefsButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'none';
                    activeChart = 0;
                } else {
                    theDefsButton.style.backgroundColor = '#ffbf00';
                    theCracksButton.style.backgroundColor = 'DodgerBlue';
                    theStrainsButton.style.backgroundColor = 'DodgerBlue';
                    theSlider.style.display = 'inline-block';
                    activeChart = 3;
                }

                updateColors();
                updateLegendText();
                render();
            }

            /*
            thePlayButton.onclick = function () {
                if (isSimulating) {
                    //We ARE active, toggle buttons OFF
                    thePlayButton.style.backgroundColor = 'DodgerBlue';
                    isSimulating = false;
                    //Stop interval...
                    window.clearInterval(theIntervalID);
                } else {
                    thePlayButton.style.backgroundColor = '#ffbf00';
                    isSimulating = true;
                    //Start interval
                    theIntervalID = window.setInterval(simulateWebsocketReceive, 4000);
                }

                updateColors();
                updateLegendText();
                render();
            }*/

            var theChartButton = document.getElementById("chart_button");
            theChartButton.onclick = function () {

                //testTcpStuff();
                //return;

                if (guiMode == 1) {
                    //We ARE active, toggle buttons OFF
                    //theChartButton.style.backgroundColor = 'DodgerBlue';
                    theStrainsButton.style.display = 'none';
                    theCracksButton.style.display = 'none';
                    theDefsButton.style.display = 'none';
                    thePlayButton.style.display = 'none';
                    theSlider.style.display = 'none';
                    guiMode = 0;
                    legendTextTop.innerText = ' ';
                    legendTextBottom.innerText = ' ';
                } else {
                    //theChartButton.style.backgroundColor = '#ffbf00';
                    if (activeChart != 0)
                        theSlider.style.display = 'inline-block';

                    theStrainsButton.style.display = 'inline-block';
                    theCracksButton.style.display = 'inline-block';
                    theDefsButton.style.display = 'inline-block';
                    thePlayButton.style.display = 'inline-block';
                    guiMode = 1;
                }

                updateLegendText();

            }

            //DALMAN - Turn off light for now...
            //const pointLight = new THREE.PointLight( 0xffffff, 1 );
            //perpCamera.add( pointLight );
            //const light = new THREE.AmbientLight(0x404040); // soft white light
            const light = new THREE.AmbientLight(0xeeeeee);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.autoClear = false;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            const controls = new OrbitControls(perpCamera, renderer.domElement);
            controls.addEventListener('change', render);

            const gui = new GUI();

            gui.add(params, 'colorMap', ['rainbow', 'cooltowarm', 'blackbody', 'grayscale', 'jet']).onChange(function () {

                updateColors();
                render();

            });

        }

        function testTcpStuff() {

            let language = navigator.language;

            console.log("Browser language: " + language);

            navigator.tcpPermission.requestPermission({ remoteAddress: "127.0.0.1", remotePort: 9999 }).then(
                () => {
                    // Permission was granted
                    // Create a new TCP client socket and connect to remote host
                    var mySocket = new TCPSocket("127.0.0.1", 9999);

                    // Send data to server
                    mySocket.writeable.write("Hello Server").then(
                        () => {

                            // Data sent sucessfully, wait for response
                            console.log("Data has been sent to server");
                            mySocket.readable.getReader().read().then(
                                ({ value, done }) => {
                                    if (!done) {
                                        // Response received, log it:
                                        console.log("Data received from server:" + value);
                                    }

                                    // Close the TCP connection
                                    mySocket.close();
                                }
                            );
                        },
                        e => console.error("Sending error: ", e)
                    );

                    // Signal that we won't be writing any more and can close the write half of the connection.
                    mySocket.halfClose();

                    // Log result of TCP connection attempt.
                    mySocket.opened.then(
                        () => {
                            console.log("TCP connection established sucessfully");
                        },
                        e => console.error("TCP connection setup failed due to error: ", e)
                    );

                    // Handle TCP connection closed, either as a result of the webapp
                    // calling mySocket.close() or the other side closed the TCP
                    // connection or an error causing the TCP connection to be closed.
                    mySocket.closed.then(
                        () => {
                            console.log("TCP socket has been cleanly closed");
                        },
                        e => console.error("TCP socket closed due to error: ", e)
                    );
                },
                e => console.error("Connection to 127.0.0.1 on port 9999 was denied due to error: ", e)
            );

        }

        function onWindowResize() {

            const width = window.innerWidth;
            const height = window.innerHeight;

            perpCamera.aspect = width / height;
            perpCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
            render();

        }

        function render() {

            renderer.clear();
            renderer.render(scene, perpCamera);

            if (guiMode == 1 && activeChart != 0) {
                renderer.render(uiScene, orthoCamera);
            }

        }

        function loadUserDataFromJSON(theJsonObj) {

            console.log('loadUserDataFromJSON - BEGIN');

            if (theJsonObj.userData) {
                //ok
            }
            else {
                return;
            }


            const geometry = new THREE.BufferGeometry();
            geometry.userData = theJsonObj.userData;

            //if ( json.userData ) geometry.userData = json.userData;
            //const geometry = new BufferGeometry();

            //const loader = new THREE.BufferGeometryLoader();

            //const geometry = loader.parse(theJsonObj);
            //if (geometry == null)
            //    return;

            updateUserData(geometry);

            updateColors();

            render();

        }

        function loadModelFromJSON(theJsonObj) {

            console.log('loadModelFromJSON - BEGIN');

            const loader = new THREE.BufferGeometryLoader();

            const geometry = loader.parse(theJsonObj);
            if (geometry == null)
                return;

            updateUserData(geometry);

            updateColors();

            render();

            /*
            geometry.computeBoundingBox();
            console.log('1: geometry.boundingBox: ', geometry.boundingBox);

            geometry.center();
            geometry.computeVertexNormals();

            geometry.computeBoundingBox();
            console.log('2: geometry.boundingBox: ', geometry.boundingBox);

            // default color attribute
            const colors = [];

            for (let i = 0, n = geometry.attributes.position.count; i < n; ++i) {

                colors.push(0, 1, 1);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            mesh.geometry = geometry;
            updateColors();

            render();

            //window.setInterval(updateColorsRandom, 2000);
            */


        }

        function simulateWebsocketReceive() {

            fetch('models/json/mainWall-contour-2023-sample.json')
                .then((response) => response.json())
                .then((json) => loadModelFromJSON(json));

        }

        function loadModel() {

            console.log('loadModel - BEGIN');

            let fetchAndThenLoad = false;

            if (fetchAndThenLoad) {

                console.log('fetchAndThenLoad is true');

                //fetch('models/json/mainWall-pos.json')
                fetch('models/json/mainWall-contour-2023-sample.json')
                    .then((response) => response.json())
                    .then((json) => loadModelFromJSON(json));
            }
            else {

                const loader = new THREE.BufferGeometryLoader();
                //loader.load( 'models/json/pressure.json', function ( geometry ) {
                //loader.load('models/json/sensitBeam4-contour.json', function (geometry) {
                //loader.load('models/json/AR_beam-contour.json', function (geometry) {
                //loader.load('models/json/AR_beam-contour2.json', function (geometry) {
                //loader.load('models/json/mainWall-contour.json', function (geometry) {

                //loader.load('models/json/mainWall-contour-22-12-08.json', function (geometry) {
                //loader.load('models/json/mainWall-contour-22-12-07.json', function (geometry) {
                //loader.load('models/json/mainWall-pos.json', function (geometry) { //Only position???
                //loader.load('models/json/AR_beam-contour2.json', function (geometry) { //SensIT v01
                loader.load('models/json/mainWall-pos.json', function (geometry) { //Only position???

                    let swapXandY = false;
                    if (swapXandY) {
                        console.log('Swapping X and Y...');
                        //First, update geometry
                        let arrayLength = geometry.attributes.position.array.length;
                        const positions = geometry.attributes.position.array;

                        let currentPos = 0;
                        for (let ii = 0, nn = geometry.attributes.position.count; ii < nn; ++ii) {

                            let X = positions[currentPos];
                            let Y = positions[currentPos + 1];
                            let Z = positions[currentPos + 2];

                            //Swap X and Z (v01: Beam approach)
                            //positions[currentPos] = Z;
                            //positions[currentPos + 2] = X;

                            //Wall approach: No need to swap :)

                            currentPos += 3;
                        }

                        geometry.attributes.position.needsUpdate = true;
                    }


                    geometry.computeBoundingBox();
                    console.log('1: geometry.boundingBox: ', geometry.boundingBox);

                    geometry.center();
                    geometry.computeVertexNormals();

                    geometry.computeBoundingBox();
                    console.log('2: geometry.boundingBox: ', geometry.boundingBox);

                    // default color attribute
                    const colors = [];

                    for (let i = 0, n = geometry.attributes.position.count; i < n; ++i) {

                        //colors.push(1, 1, 1);
                        colors.push(1, 0, 1);

                    }

                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    mesh.geometry = geometry;
                    updateColors();

                    render();

                    //window.setInterval(updateColorsRandom, 2000);
                    //window.setInterval(simulateWebsocketReceive, 4000);

                });
            }

            console.log('loadModel - END');

        } //END - function loadModel()

        function updateLegendText() {

            if (guiMode == 0) {
                legendTextTop.innerText = ' ';
                legendTextBottom.innerText = ' ';
                legendTextDateTime.innerText = ' ';
            } else if (activeChart == 0) {
                legendTextTop.innerText = ' ';
                legendTextBottom.innerText = ' ';
                legendTextDateTime.innerText = ' ';
            } else if (activeChart == 1) {
                legendTextTop.innerText = '1327';
                legendTextBottom.innerText = '-647';
                legendTextDateTime.innerText = date_time;
            } else if (activeChart == 2) {
                legendTextTop.innerText = '0.68';
                legendTextBottom.innerText = '0.0';
                legendTextDateTime.innerText = date_time;
            } else if (activeChart == 3) {
                legendTextTop.innerText = '0.0';
                legendTextBottom.innerText = '-4.52';
                legendTextDateTime.innerText = date_time;
            }

        }

        function updateColorsRandom() {
            const geometry = mesh.geometry;
            if (geometry == null)
                return;

            const colors = geometry.attributes.color;

            if (colors == null)
                return;

            for (let i = 0, n = geometry.attributes.position.count; i < n; ++i) {

                colors.setXYZ(i, Math.random(), Math.random(), Math.random());
            }

            colors.needsUpdate = true;

            render();

        }

        //This is typically what we get from the WebSocket "stream"
        function updateUserData(theGeometry) {

            //EPS_MAX
            const eps_max = theGeometry.userData.eps_max;
            if (eps_max == null) {
                console.log('eps_max is null!');
                //return;
            }
            else {
                console.log('eps_max.length:', eps_max.length);
                let randomVal = Math.random() * 1000.0; //If null, we replace with this
                for (let i = 0; i < eps_max.length; i++) {
                    if (eps_max[i] == null)
                        eps_max[i] = randomVal;
                }

                //Can we really do like this..?
                mesh.geometry.userData.eps_max = eps_max;
                //
                //or:
                //mesh.geometry.userData = null; //"add" userData as property??
                //mesh.geometry.userData.eps_max = eps_max;

                console.log('mesh.geometry.userData.eps_max.length:', mesh.geometry.userData.eps_max.length);

            }

            //EPS_MIN
            const eps_min = theGeometry.userData.eps_min;
            if (eps_min == null) {
                console.log('eps_min is null!');
                //return;
            }
            else {
                console.log('eps_min.length:', eps_min.length);

                let randomVal = Math.random() * 1.0; //If null, we replace with this
                for (let i = 0; i < eps_min.length; i++) {
                    if (eps_min[i] == null)
                        eps_min[i] = randomVal;
                }

                //Can we really do like this..?
                mesh.geometry.userData.eps_min = eps_min;
            }

            //ETA_XY
            const eta_xy = theGeometry.userData.eta_xy;
            if (eta_xy == null) {
                console.log('eta_xy is null!');
                //return;
            }
            else {
                console.log('eta_xy.length:', eta_xy.length);

                let randomVal = Math.random() * 5.0; //If null, we replace with this
                for (let i = 0; i < eta_xy.length; i++) {
                    if (eta_xy[i] == null)
                        eta_xy[i] = randomVal;
                }

                //Can we really do like this..?
                mesh.geometry.userData.eta_xy = eta_xy;
            }


            //updateColors();

        }

        function onClickCloseSocketButton() {
            if (theWebsocket == null) {
                console.log('cannot close non-open socket!');
            }
            else {
                theWebsocket.close();
                theWebsocket = null;
            }
        }

        function onClickSendKButton() {
            console.log('onClickSendKButton');
            if (theWebsocket == null) {
                //Socket not connected yet...
            }
            else {
                theWebsocket.send('k');
            }
        }

        function onClickSendButton() {

            console.log('onClickSendButton');
            const text = theTextArea.value;
            //console.log(text);
            theWebsocket = new WebSocket(text);

            theWebsocket.onopen = (e) => {

                console.log('CONNECTED');
                //writeToScreen("CONNECTED");
                //doSend("WebSocket rocks");
            };

            theWebsocket.onclose = (e) => {
                console.log('DISCONNECTED');
                //writeToScreen("DISCONNECTED");
            };

            theWebsocket.onmessage = (e) => {
                console.log('onmessage');
                //writeToScreen(`<span>RESPONSE: ${e.data}</span>`);

                //if (e.data.startsWith('{"metadata"'))
                if (e.data.startsWith('{')) {
                    let theDataAsJson = JSON.parse(e.data);
                    //loadModelFromJSON(theDataAsJson);
                    loadUserDataFromJSON(theDataAsJson);

                    //let theDataAsJson = JSON.parse(`${e.data}`); //Who am I kidding :)
                    //loadModelFromJSON(theDataAsJson);

                    //loadModelFromJSON(e.data)
                }
                else {
                    //This should be the time interval, right..?
                    console.log(e.data);
                }
            };

            theWebsocket.onerror = (e) => {
                console.log('onerror');
                console.log(e.data);
                //writeToScreen(`<span class="error">ERROR:</span> ${e.data}`);
            };



        }

        function updateColors() {

            //NOTE: For the beam we had:
            //strains
            //cracks
            //defs
            //time
            //For the wall we have:
            //eps_max
            //eps_min
            //eta_xy
            //Also different: strains was an array containing one array (values) per timestep
            //eps_max is a single array, i.e. a single timestep

            const geometry = mesh.geometry;
            //const strains = geometry.userData.strains;
            const strains = geometry.userData.eps_max;
            if (strains == null) {
                console.log('strains is null!');
                return;
            }

            console.log('strains.length:', strains.length);

            //const strains_0 = strains[0];
            //const strains_0 = strains[1];

            console.log('geometry.attributes.position.count:', geometry.attributes.position.count); //geometry.attributes.position.count: 45000
            console.log('geometry.attributes.position.array.length:', geometry.attributes.position.array.length);

            //console.log('strains.array.length:', strains.array.length);
            //strains.length: 5
            //console.log('strains_0.length:', strains_0.length); //strains_0.length: 45000

            //const cracks = geometry.userData.cracks;
            const cracks = geometry.userData.eps_min;
            //const defs = geometry.userData.defs;
            const defs = geometry.userData.eta_xy;
            /*const time = geometry.userData.time;*/

            console.log('cracks.length:', cracks.length); //45
            console.log('defs.length:', defs.length); //45
            /*console.log('time.length:', time.length);*/ //45


            //lut.setColorMap(params.colorMap);//Original
            //lut.setColorMap(params.colorMap, 64);
            //lut.setColorMap(params.colorMap, 128);

            //Strains [-814, 1079]
            //lut.setMax(1079);
            //lut.setMin(-814);

            //Cracks:
            //maxValue: 0.11
            //minValue: -0.05
            //lut.setMax(0.111);
            //lut.setMin(-0.051);

            //Defs [-0.321, 3.561]
            //lut.setMax(3.561);
            //lut.setMin(-0.321);

            //lut.setMax(23);
            //lut.setMin(-38);

            //const geometry = mesh.geometry;
            //const pressures = geometry.attributes.pressure;
            //const pressures = strains[0]; //DALMAN
            //const pressures = strains[10]; //DALMAN

            //const pressures = strains[currentSensorIdx]; //DALMAN
            //const pressures = cracks[currentSensorIdx]; //DALMAN
            //const pressures = defs[currentSensorIdx]; //DALMAN
            let pressures = null;
            if (activeChart == 0) {
                lut.setMax(10);
                lut.setMin(0);

                const colors0 = geometry.attributes.color;
                //for (let j = 0; j < strains[currentSensorIdx].length; j++) {
                for (let j = 0; j < strains.length; j++) {
                    //colors0.setXYZ(j, 1, 0, 0.5);
                    if (j == 0 || j == 1 || j == 2 || j == 3) {
                        colors0.setXYZ(j, 1, 0, 0);
                    } else {
                        colors0.setXYZ(j, 1, 1, 1);
                    }

                }

                colors0.needsUpdate = true;
                return;

            } else if (activeChart == 1) {
                //lut.setMax(1079);
                //lut.setMin(-814);

                lut.setMax(1327);
                lut.setMin(-647);

                //pressures = strains[currentSensorIdx];
                pressures = strains;
            } else if (activeChart == 2) {
                //lut.setMax(0.111);
                //lut.setMin(0.0); //clamp

                lut.setMax(0.68);
                lut.setMin(0.0); //clamp

                //pressures = cracks[currentSensorIdx];
                pressures = cracks;
            } else if (activeChart == 3) {
                //lut.setMax(3.561);
                //lut.setMin(-0.321);
                //neg
                //lut.setMax(0.0); //clamp
                //lut.setMin(-3.561); //negate

                //lut.setMax(4.52);
                //lut.setMin(0.0); //clamp

                //As negative:
                lut.setMax(0.0); //clamp
                lut.setMin(-4.52); //negate

                //pressures = defs[currentSensorIdx];
                pressures = defs;
            }

            const colors = geometry.attributes.color;



            //First, a pre-loop in order to get min/max

            let maxValue = -1000;
            let minValue = 1000;

            for (let ii = 0; ii < pressures.length; ii++) {

                //const colorValue = pressures.array[ i ];
                const colorValue = pressures[ii];

                if (colorValue > maxValue)
                    maxValue = colorValue;

                if (colorValue < minValue)
                    minValue = colorValue;

            }

            console.log('currentSensorIdx:', currentSensorIdx);
            console.log('activeChart:', activeChart);
            console.log('maxValue:', maxValue);
            console.log('minValue:', minValue);

            /*
            console.log('date_time:', time[currentSensorIdx]);
            date_time = time[currentSensorIdx];
            */


            //console.log('currentSensorIdx:', currentSensorIdx);
            //console.log('activeChart:', activeChart);


            //lut.setMax(maxValue + 1);
            //lut.setMin(minValue - 1);

            //for ( let i = 0; i < pressures.array.length; i ++ ) {
            for (let i = 0; i < pressures.length; i++) {

                //const colorValue = pressures.array[ i ];
                //const colorValue = pressures[i];
                let colorValue = 0.0;
                if (activeChart == 3) {
                    colorValue = -pressures[i]; //negate deflection so its similar as the Matlab plots
                } else {
                    colorValue = pressures[i];
                }


                const color = lut.getColor(colorValue);

                if (color === undefined) {

                    console.log('Unable to determine color for value:', colorValue);

                } else {

                    colors.setXYZ(i, color.r, color.g, color.b);

                }

            }



            //For strains_0:
            //maxValue: 22
            //minValue: -37

            colors.needsUpdate = true;

            /*
            const map = sprite.material.map;
            lut.updateCanvas(map.image);
            map.needsUpdate = true;
            */


        }

    </script>

</body>
</html>
